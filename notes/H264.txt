H264码流


SPS：Sequence Parameter Set 序列参数集	H.264码流的第一个NALU

保存了一组编码视频序列（Coded video sequence）的全局参数，即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列

每一帧的编码后数据所依赖的参数保存于图像参数集中

一般情况SPS和PPS的NALU通常位于整个码流的起始位置。

特殊情况下，码流中间也可能出现这两种结构，主要原因如下：
1、解码器需要在码流中间开始解码
2、编码器在编码过程中改变了码流参数（如分辨率）

语法元素含义：

（1）profile_idc：
	标识当前H.264码流的profile（H.264的SPS中，第一个字节标识profile_idc）
	H.264中三种常用的profile：baseline profile = 66、main profile = 77、extended profile = 88

（2）level_idc：
	标识当前码流的level。编码的level定义了某种条件下的最大视频分辨率、最大视频帧率等参数

（3）seq_parameter_set_id：
	标识当前的序列参数及的id，通过该值，图像参数集PPS中可以引用其代表的SPS中的参数

（4）log2_max_frame_num_minus4
	用于计算MaxFrameNum的值，公式为MaxFrameNum = 2^(log2_max_frame_num_minus4 + 4)
	MaxFrameNum是frame_num的上限值，frame_num是图像序号的一种表示方法，在帧间编码中常用作一种参考帧标记的手段

（5）pic_order_cnt_type
	表示解码picture order count（POC）的方法。POC是另一种计量图像序号的方式，与frame_num计算方法不同。该语法元素取值为0、1、2

（6）log2_max_pic_order_cnt_lsb_minus4
	用于计算MaxPicOrderCntLsb的值，该值表示POC的上限。MaxPicOrderCntLsb = 2^(log2_max_pic_order_cnt_lsb_minus4 + 4)

（7）max_num_ref_frames
	表示参考帧的最大数目

（8）gaps_in_frame_num_value_allowed_flag
	标志位，说明frame_num中是否允许不连续的值

（9）pic_width_in_mbs_minus1
	用于计算图像的宽度。单位为宏块个数，因此图像的实际宽度为frame_width = 16 * (pic_width_in_mbs_minux1 + 1)

（10）pic_height_in_map_units_minus1
	使用PicHeightInMapUnits来度量视频中一帧图像的高度，该值并非图像明确的以像素或宏块为单位的高度，而需要考虑该宏块是帧编码或场编码
	PicHeightInMapUnits = pic_height_in_map_units_minus1 + 1

（11）frame_mbs_only_flag
	标志位，说明宏块的编码方式
	0：宏块可能为帧编码或场编码。PicHeightInMapUnits表示一场数据按宏块计算的高度
	1：所有宏块采用帧编码。PicHeightInMapUnits表示一帧数据按宏块计算的高度。FrameheightInMbs = ( 2 − frame_mbs_only_flag ) * PicHeightInMapUnits

（12）mb_adaptive_frame_field_flag
	标志位，说明是否采用了宏块级的帧、场自适应编码
	0：不存在帧编码和场编码之间的切换
	1：宏块可能在帧编码和场编码模式之间进行选择

（13）direct_8x8_inference_flag
	标志位，用于B_Skip、B_Direct模式运动矢量的推导计算

（14）frame_cropping_flag
	标志位，说明是否需要对输出的图像帧进行裁剪

（15）vui_parameters_present_flag
	标志位，说明SPS中是否存在VUI信息



PPS：Picture Parameter Set 图像参数集		H.264码流的第二个NALU nal_unit_type为8

语法元素含义：
（1）pic_parameter_set_id：
	表示当前PPS的id，某个PPS在码流中会被相应的slice引用，引用PPS的方式就是在Slice header中保存PPS的id值，取值的范围[0, 255]

（2）seq_parameter_set_id：
	表示当前PPS所引用的激活的SPS的id，通过这种方式，PPS中也可以取到对应SPS中的参数，取值范围[0, 31]

（3）entropy_coding_mode_flag
	熵编码模式标志，该标志位标识码流中熵编码/解码选择的算法。对于部分语法元素，在不同的编码配置下，选择的熵编码方式不同
	如：在一个宏块语法元素中，宏块类型mb_type的语法元素描述符为“ue(v) | ae(v)”，在baseline profile等设置下采用指数哥伦布编码，在main profile等设置下采用CABAC编码
	标志位entropy_coding_mode_flag的作用就是控制这种算法选择
	0：选择左边的算法，通常为指数哥伦布编码或者CAVLC
	1：选择右边的算法，通常为CABAC

（4）bottom_field_pic_order_in_frame_present_flag
	标志位，用于标识另外条带头中两个语法元素delta_pic_ordercnt_bottom和delta_pic_order_cn是否存在的标志
	这两个语法元素表示了某一帧的底场的POC的计算方法

（5）num_slice_groups_minus1
	表示某一帧中slice group的个数。
	0：一帧中所有的slice都属于一个slice group。slice group是一帧中宏块的组合方法

（6）num_ref_idx_I0_default_active_minux1、num_ref_idx_I0_default_active_minus1
	表示当Slice Header中的num_ref_idx_active_override_flag标志位为0时，P/SP/B slice的语法元素
	num_ref_idx_I0_active_minus1和num_ref_idx_l1_active_minus1的默认值

（7）weighted_pred_flag
	标志位，表示在P/SP slice中是否开启加权预测

（8）weighted_bipred_idc
	表示在B slice中加权预测的方法，取值范围[0, 2]
	0：默认加权预测
	1：显示加权预测
	2：隐式加权预测

（9）pic_init_qp_minus26、pic_init_qs_minus26
	表示初始的量化参数。实际的量化参数由该参数、slice header中的slice_qp_delta/slice_qs_delta计算得到

（10）chroma_qp_index_offset
	用于计算色度分量的量化参数，取值范围为[-12,12]。

（11）deblocking_filter_control_present_flag
	标识位，用于表示Slice header中是否存在用于去块滤波器控制的信息。
	0：slice header中没有相应的信息。
	1：slice header中包含去块滤波相应的信息

（12）constrained_intra_pred_flag
	0：表示I宏块可以使用来自Inter类型宏块的信息。
	1：表示I宏块在进行帧内预测时只能使用来自I和SI类型宏块的信息

（13）redundant_pic_cnt_present_flag
	标识位，用于表示Slice header中是否存在redundant_pic_cnt语法元素。
	0：slice header中没有相应的信息。
	1：slice header中包含redundant_pic_cnt



IDR：Instantaneous Decoding Refresh 即时解码刷新	H.264码流的第三个NALU


一帧图片经过 H.264 编码器之后，就被编码为一个或多个片（slice）。<编码阶段,由VCL实现>
而装载着这些片（slice）的载体，就是 NALU 
 NALU 跟片的关系（slice）<由NAL实现>
注意：实际中NAL还要对切片进行处理，然后形成NALU。
	| NALU 头部 | 一个切片 |
		           ||
		           V
		| 切片头 | 切片数据 |



片（slice）的概念不同与帧（frame），帧（frame）是用作描述一张图片的，一帧（frame）对应一张图片，
而片（slice），是 H.264 中提出的新概念，是通过编码图片后切分通过高效的方式整合出来的概念，
一张图片至少有一个或多个片（slice）。

片（slice）都是又 NALU 装载并进行网络传输的，但是这并不代表 NALU 内就一定是切片，
这是充分不必要条件，因为 NALU 还有可能装载着其他用作描述视频的信息，比如SPS、PPS。

片的主要作用是用作宏块（Macroblock）的载体。片之所以被创造出来，主要目的是为限制误码的扩散和传输。

如何限制误码的扩散和传输？
	每个片（slice）都应该是互相独立被传输的，某片的预测（片（slice）内预测和片（slice）间预测）
	不能以其它片中的宏块（Macroblock）为参考图像。

	| Slice |
	    ||
	    V
	| 片头 | 片数据 |
		||
		V
	          | 宏块 | 宏块 | 宏块| 。。。|

每个分片也包含着头和数据两部分：
	1、分片头中包含着分片类型、分片中的宏块类型、分片帧的数量、分片属于那个图像以及对应的帧的设置和参数等信息。 
	2、分片数据中则是宏块，这里就是我们要找的存储像素数据的地方。

宏块是视频信息的主要承载者，因为它包含着每一个像素的亮度和色度信息。
视频解码最主要的工作则是提供高效的方式从码流中获得宏块中的像素阵列。

组成部分：一个宏块由一个16×16亮度像素和附加的一个8×8 Cb和一个 8×8 Cr 彩色像素块组成。
	每个图象中，若干宏块被排列成片的形式。

	| 宏块 |
	    ||
	    V
	| 宏块类型 | 预测类型 | C P B | QP | 宏块数据 |
				          ||
				          V
				| Y | Cb | Cr |

宏块中包含了宏块类型、预测类型、​ ​Coded Block Pattern 编码的块模式​​​、​​Quantization Parameter 量化参数​​、像素的亮度和色度数据集等等信息。


切片（slice）类型跟宏块类型的关系

	I片：只包 I宏块，I 宏块利用从当前片中已解码的像素作为参考进行帧内预测(不能取其它片中的已解码像素作为参考进行帧内预测)。

	P片：可包 P和I宏块，P 宏块利用前面已编码图象作为参考图象进行帧内预测，一个帧内编码的宏块可进一步作宏块的分割:即 16×16、16×8、8×16 或 8×8 亮度像素块(以及附带的彩色像素);如果选了 8×8 的子宏块，则可再分成各种子宏块的分割，其尺寸为 8×8、8×4、4×8 或 4×4 亮度像素块(以及附带的彩色像素)。

	B片：可包 B和I宏块，B 宏块则利用双向的参考图象(当前和 来的已编码图象帧)进行帧内预测。

	SP片(切换P)：用于不同编码流之间的切换，包含 P 和/或 I 宏块

	SI片：扩展档次中必须具有的切换，它包 了一种特殊类型的编码宏块，叫做 SI 宏块，SI 也是扩展档次中的必备功能。



H.264的两种打包/封装方法：字节流AnnexB格式 和 AVCC格式 （只有这两种）
在H264用于网络发送时，要封装成RTP格式！！！

1.AnnexB流结构：
	使用start code分隔NAL(start code为三字节或四字节，0x000001或0x00000001，一般是四字节)；
	SPS和PPS按流的方式写在头部。
	开始前缀（00000001或000001）＋ NALU数据 绝大部分编码器的默认输出格式

NALU 就是 h264的实际数据部分。

NALU = NALUHeader+EBSP 组成; EBSP = 防止竞争码+RBSP; RBSP = SODB + RBSP尾部 。

EBSP为扩展字节序列载荷（Encapsulated Byte Sequence Payload）  EBSP = RBSP插入防竞争字节（0x03）

RBSP为原始字节序列载荷（Raw Byte Sequence Payload）--------   RBSP = SODB + RBSP Trailing Bits（RBSP尾部补齐字节）;引入RBSP Trailing Bits做8位字节补齐。

SODB为原始数据比特流  （String Of Data Bits）　　　-------　　　就是最原始的编码/压缩得到的数据。、

H264 码流结构

	H.264 Annex B 格式
		||
		V
        | 起始码 | NALU |         | 起始码 | NALU |          | 起始码 | NALU | 
	          ||
	          V
	 | NALU Header | EBSP |
			||  去除0x03
			V
			| RBSP |
			      ||  去除 RBSP 尾部
			      V
			  | SODB | 

一共有两种起始码start_code：

	1、3字节0x000001  单帧多slice（即单帧多个NALU）之间间隔    
	2、4字节0x00000001 帧之间，或者SPS、PPS等之前

4字节类型的起始码在连续的数据传输中非常有用，因为用字节来对齐、分割流数据，
比如：用连续的31个bit 0 后接一个bit 1 来分割流数据，是很容易的。

如果接下来的bit是0(因为每个NALU都以bit0开始)，那么这就是一个NALU包数据的起始位置了。
4字节类型的开始码通常只用于标识流中的随机访问点，如SPS PPS AUD和IDR，然后其他地方都用3字节类型的开始码以减少数据量。

防止竞争字节（​​0x03​​）:
	前面讲到用StartCode的字节串来分割NALU，于是问题来了，
	如果RBSP中也包括了StartCode（0x000001或0x00000001）怎么办呢？
	所以，就有了防止竞争字节（0x03）：

编码时，扫描RBSP，如果遇到连续两个0x00字节，就在后面添加防止竞争字节（0x03）；

解码时，同样扫描EBSP，进行逆向操作即可。

编码示例如下：
	0x000000    ===>    0x00000300
	0x000001    ===>    0x00000301
	0x000002    ===>    0x00000302
	0x000003    ===>    0x00000303

解码操作：
	在解码的时候如果在内部遇到0x000003序列时，就可以将其抛弃即可以恢复原始数据。
	EBSP 去除防止竞争码后就可以得到 RBSP。


AU分隔：
	一个单独的NALU包、或者甚至一个VCL NALU包都不意味着是一个独立的帧，
	一帧数据可以被分割成几个NALU，一个或多个NALU组成了一个Access Units(AU)，
	AU包含了一个完整的帧。把帧分割成几个独立的NALU需要耗费许多CPU资源，所以分割帧数据并不经常使用。


